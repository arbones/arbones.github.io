<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="JM">
<meta name="dcterms.date" content="2026-01-04">

<title>Why Your Spatial Transcriptomics Analysis Might Be Lying to You (I) – ADIPOFAT</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">ADIPOFAT</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://arbones.github.io/adipo2/"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/arbones?tab=repositories"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/user/AdipoFat"> <i class="bi bi-youtube" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Why Your Spatial Transcriptomics Analysis Might Be Lying to You (I)</h1>
            <p class="subtitle lead">A deep dive into normalization methods and why the tools we borrowed from single-cell RNA-seq don’t always work for spatial data</p>
                                <div class="quarto-categories">
                <div class="quarto-category">SingleCell</div>
                <div class="quarto-category">SRT</div>
                <div class="quarto-category">Normalization</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>JM </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 4, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>So here’s the thing about analyzing gene expression data. You load up your Xenium or Visium dataset, you run the standard Seurat or SpatialData pipelines because that’s what everyone does, you get your clusters, and you write your paper. Great. Except maybe not great, because it turns out that the normalization step you copied from the single-cell RNA-seq tutorial might be quietly removing the very biological signal you’re trying to find.</p>
<p>This isn’t hypothetical hand-waving. Data from recent benchmarking studies tells a pretty clear story. <em>When you apply standard single-cell normalization methods to spatial transcriptomics data, especially in tissues with anatomically structured variation in cell density or RNA content, you can inadvertently erase genuine biology</em>. The cortical white matter doesn’t have uniform cell packing. The liver lobule has zones with different metabolic activities and different RNA abundances. These regional differences aren’t technical noise, they’re the biology. But if you normalize them away, they’re gone.</p>
<p>Let’s unpack how we got here and what we can do about it.</p>
<section id="the-normalization-problem-what-were-actually-trying-to-fix" class="level2">
<h2 class="anchored" data-anchor-id="the-normalization-problem-what-were-actually-trying-to-fix">The Normalization Problem: What We’re Actually Trying to Fix</h2>
<p>Single-cell RNA sequencing generates count matrices where each number represents detected mRNA molecules. The raw count for any gene in any cell reflects true expression plus a whole stack of technical artifacts. Cell lysis efficiency varies. mRNA capture rates fluctuate. Amplification introduces biases. Sequencing depth differs across cells. These technical factors create cell-specific and gene-specific effects that confound biological interpretation if you don’t correct for them.</p>
<p>The standard approach has been to compute some kind of size factor per cell and scale everything uniformly. LogNormalize in Seurat does exactly this. It divides each gene’s count by the total counts in that cell, multiplies by 10,000, and takes the log. The math is simple: log(count/total × 10000 + 1). The assumption is also simple: all genes scale uniformly with sequencing depth. This assumption works reasonably well for identifying cell types in peripheral blood mononuclear cells or dissociated tissues where cells are randomly distributed.</p>
<p>Here’s where spatial data breaks that assumption. In spatial transcriptomics, cells aren’t randomly distributed. They’re organized into anatomical structures with systematic differences in cell density, cell types, and transcriptional activity. The white matter has fewer cells than gray matter. The portal zone of the liver lobule has different metabolic demands than the central vein region. These spatial gradients in total RNA content aren’t technical artifacts, they’re biology. When you normalize by total counts per spot or per cell, you’re assuming that variation in library size is purely technical. But what if it’s not?</p>
</section>
<section id="from-simple-scaling-to-statistical-frameworks" class="level2">
<h2 class="anchored" data-anchor-id="from-simple-scaling-to-statistical-frameworks">From Simple Scaling to Statistical Frameworks</h2>
<p>The field has evolved from these simple scaling approaches toward methods that model the statistical properties of count data more carefully. I’ll walk through the major categories because understanding the underlying logic matters more than memorizing method names.</p>
<p><strong>Global scaling methods</strong> like LogNormalize, CPM (counts per million), and TPM (transcripts per million) compute a single size factor per cell and scale all counts uniformly. These work fine when the assumption holds that library size variation is mostly technical. TPM adds gene length correction, which matters for full-length protocols but not for 3’ end counting methods where one transcript generates one count regardless of length.</p>
<p><strong>Pooling-based methods</strong> like scran take a different approach. Instead of computing size factors from individual cells, which fails when cells have lots of zeros, scran aggregates counts across pools of similar cells. This overcomes zero inflation by working with more robust pool-level totals before deconvolving back to cell-level factors. The method explicitly addresses the dropout problem where expressed transcripts fail to be captured.</p>
<p><strong>Regression-based methods</strong> model count data using generalized linear models with sequencing depth as a covariate. SCTransform represents the most widely adopted approach in this category. It fits a regularized negative binomial regression for each gene, modeling the mean-variance relationship and stabilizing variance across expression levels. The second version (SCTransform v2) improves handling of datasets with different sequencing depths across conditions, which reduces false positives in differential expression analysis.</p>
<p><strong>Bayesian methods</strong> like BASiCS and SCDE use probabilistic frameworks to separate technical from biological variation. These approaches model dropout events explicitly and can distinguish biological zeros from technical failures. The trade-off is computational cost, which scales poorly to large datasets.</p>
<p><strong>Deep learning methods</strong> like scVI use variational autoencoders to learn low-dimensional representations while accounting for technical noise. The model learns to disentangle biological variation from batch effects and library size effects without requiring explicit statistical assumptions about the count distribution. These methods work particularly well for integration tasks where you’re combining multiple datasets.</p>
<p><strong>Count-preserving methods</strong> represent an alternative philosophy. Instead of transforming counts through normalization, methods like countland work directly with integer counts using models that naturally handle count data. This preserves the discrete nature of molecular counting and avoids potential artifacts from log transformations.</p>
<p>Each approach makes different assumptions about the data generating process. No single method wins across all contexts.</p>
</section>
<section id="what-works-for-single-cell-rna-seq" class="level2">
<h2 class="anchored" data-anchor-id="what-works-for-single-cell-rna-seq">What Works for Single-Cell RNA-seq</h2>
<p>Benchmarking studies have evaluated these methods across diverse datasets and analytical tasks. For standard single-cell RNA-seq analysis, particularly with UMI-based protocols like 10x Genomics, current best practices converge on a few options.</p>
<p>SCTransform v2 performs well for clustering and differential expression, especially when comparing conditions with different sequencing depths. The variance stabilization it provides reduces the impact of mean-variance relationships that can create spurious patterns. Scran remains a solid choice, particularly for integration workflows where it’s been extensively validated. Recent work suggests Dino, which models the full distribution of counts for variance stabilization, performs particularly well for high-throughput clustering applications.</p>
<p>The key insight is that method choice depends on experimental context and analytical goals. Full-length protocols like Smart-seq2 benefit from gene length normalization that’s irrelevant for UMI data. Integration tasks may favor deep learning approaches that can handle complex batch structures. Differential expression testing requires methods that control false positive rates appropriately.</p>
</section>
<section id="where-spatial-data-breaks-the-rules" class="level2">
<h2 class="anchored" data-anchor-id="where-spatial-data-breaks-the-rules">Where Spatial Data Breaks the Rules</h2>
<p>Spatial transcriptomics introduces a fundamental complication. The spatial association between region-specific library size and underlying biology means that standard normalization can remove genuine signal.</p>
<p><img src="spatial.png" class="img-fluid"></p>
<p>Consider a Visium experiment profiling brain tissue. Cortical white matter has lower cell density and lower total RNA content than gray matter. This creates a spatial gradient in library size that corresponds to anatomical structure. If you apply standard LogNormalize, you’re implicitly treating this gradient as technical noise and normalizing it away. But the gradient is biology. Different brain regions have different cellular compositions and different transcriptional programs.</p>
<p>This problem becomes even more acute with subcellular resolution platforms like Xenium or CosMx. Individual cells have spatial organization of organelles, transcripts localize to specific subcellular compartments, and RNA abundance varies systematically across cellular domains. Normalizing by cell-level totals can obscure these patterns.</p>
<p>Recent work from Svensson and colleagues demonstrated this problem empirically. They showed that applying standard single-cell normalization methods to spatial data can reduce performance in spatial domain identification tasks. In some datasets, unnormalized or minimally normalized data (just log transformation) outperformed aggressively normalized data for identifying anatomical regions.</p>
<p>The issue is that we borrowed tools designed for one problem (technical variation in dissociated single cells) and applied them to a different problem (spatial biology where location matters). The assumptions don’t transfer cleanly.</p>
</section>
<section id="practical-recommendations-what-to-actually-do" class="level2">
<h2 class="anchored" data-anchor-id="practical-recommendations-what-to-actually-do">Practical Recommendations: What to Actually Do</h2>
<p>When analyzing spatial transcriptomics data, start by examining the raw data. Plot spatial distributions of total counts and key marker genes. Look for regional patterns. If you see systematic spatial variation that corresponds to known anatomical structures, be cautious about aggressive normalization.</p>
<p>For spatial domain identification, consider minimal normalization or log transformation without scaling. Recent benchmarks suggest this often works better than methods that remove spatial library size variation.</p>
<p>If you use standard methods like LogNormalize, validate your results against known biology. Marker genes with established spatial patterns provide internal validation. If your normalized data shows uniform expression of a gene that should be spatially restricted, your normalization likely removed signal.</p>
<p>For imaging-based platforms with defined gene panels, evaluate whether the panel composition introduces systematic biases. Consider area-based or volume-based normalization as alternatives to count-based methods, particularly for subcellular resolution data.</p>
<p>SpaNorm provides a purpose-built solution for data where spatial library size variation reflects biology. The method is most valuable for tissues with strong anatomical organization and for subcellular resolution platforms.</p>
<p>For differential expression analysis in spatial data, pseudobulk approaches that aggregate spots within regions and apply bulk methods remain a robust choice. This sidesteps many normalization challenges by working at the region level rather than spot level.</p>
</section>
<section id="the-deeper-issue-technical-noise-versus-biological-signal" class="level2">
<h2 class="anchored" data-anchor-id="the-deeper-issue-technical-noise-versus-biological-signal">The Deeper Issue: Technical Noise Versus Biological Signal</h2>
<p>The normalization problem in spatial transcriptomics highlights a broader challenge in computational biology. We build tools to remove technical variation, but those tools encode assumptions about what counts as technical versus biological. When data structure violates those assumptions, our corrections become overcorrections.</p>
<p>This matters because spatial transcriptomics is moving toward higher resolution, greater multiplexing, and multimodal integration. Subcellular resolution platforms let us see transcript localization patterns. Multiplexed imaging adds protein measurements. These technologies generate data where spatial structure carries biological information that we need to preserve.</p>
<p>The solution isn’t to abandon normalization. Raw count data has real technical artifacts that need correction. The solution is to develop methods that respect spatial structure while removing noise. SpaNorm represents a first step. Methods that incorporate tissue architecture, cell type composition, and spatial autocorrelation will likely follow.</p>
<p>For multimodal data combining RNA and protein measurements, we need modality-specific approaches. Protein data from CITE-seq experiments shows different statistical properties than RNA counts. Methods like CLR (centered log ratio) and dsb explicitly address antibody-derived protein data characteristics. As technologies integrate more data types, normalization strategies will need corresponding sophistication.</p>
</section>
<section id="what-this-means-for-your-analysis" class="level2">
<h2 class="anchored" data-anchor-id="what-this-means-for-your-analysis">What This Means for Your Analysis</h2>
<p>If you’re analyzing spatial transcriptomics data, the default pipeline might not be your friend. The standard workflow that works beautifully for PBMC single-cell data can quietly remove spatial biology from tissue data.</p>
<p>Before normalizing, understand what your method assumes. LogNormalize assumes uniform scaling relationships. SCTransform assumes mean-variance relationships follow a specific form. Deep learning methods make implicit assumptions through their architecture choices. If your data violates these assumptions, your normalization will distort your results.</p>
<p>Validate against known biology. If you have marker genes with established spatial patterns, check that your normalized data preserves those patterns. If normalization removes them, you’ve overcorrected.</p>
<p>Consider whether you need normalization for your specific analysis. For some spatial domain identification tasks, minimal processing works better than aggressive normalization. For differential expression, pseudobulk approaches offer robustness. For integration, spatially-aware methods matter.</p>
<p>The fundamental goal remains unchanged: distinguish technical variation from biological variation while preserving the latter. But in spatial data, where spatial variation is often biological, we need tools that respect that structure.</p>
</section>
<section id="looking-forward" class="level2">
<h2 class="anchored" data-anchor-id="looking-forward">Looking Forward</h2>
<p>The field is moving fast. Spatial transcriptomics technologies continue to improve in resolution and throughput. Normalization methods are adapting accordingly. Spatially-aware approaches will become more sophisticated as we better understand tissue architecture and spatial gene expression patterns.</p>
<p>Integration of multiple data modalities will require normalization methods that handle RNA, protein, metabolites, and morphological features simultaneously. Each modality has different noise characteristics and different scaling relationships.</p>
<p>Machine learning approaches will likely play an increasing role. Methods that learn normalization strategies from data rather than imposing parametric assumptions could adapt to diverse experimental contexts. The challenge will be maintaining interpretability and biological validity.</p>
<p>For now, the practical advice is simple. Understand your tools. Validate your results. Don’t assume that methods designed for single-cell RNA-seq transfer directly to spatial data. The biology is different, the technical artifacts are different, and the normalization strategy should be different too.</p>
<p>Your spatial transcriptomics data contains rich biological information about tissue organization, cellular interactions, and spatial gene expression patterns. Choose normalization methods that preserve that information rather than normalize it away.</p>
<hr>
</section>
<section id="further-reading" class="level2">
<h2 class="anchored" data-anchor-id="further-reading">Further Reading</h2>
<p>For those who want to dive deeper into the technical details, the key references include:</p>
<p><strong>On standard normalization methods:</strong> - Hafemeister C, Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression. <em>Genome Biology</em> 2019. https://doi.org/10.1186/s13059-019-1874-1</p>
<ul>
<li>Lun ATL, et al.&nbsp;Pooling across cells to normalize single-cell RNA sequencing data with many zero counts. <em>Genome Biology</em> 2016. https://doi.org/10.1186/s13059-016-0947-7</li>
</ul>
<p><strong>On spatial-specific challenges:</strong> - Svensson V, et al.&nbsp;(References to SpaNorm and spatial normalization challenges from the original report)</p>
<p><strong>On deep learning approaches:</strong> - Lopez R, et al.&nbsp;Deep generative modeling for single-cell transcriptomics. <em>Nature Methods</em> 2018. https://doi.org/10.1038/s41592-018-0229-2</p>
<p><strong>On benchmarking:</strong> - Brown J, et al.&nbsp;Normalization by distributional resampling of high throughput single-cell RNA-sequencing data. <em>Bioinformatics</em> 2021. https://doi.org/10.1093/bioinformatics/btab450 - Marco-Salas S, et al.&nbsp;Optimizing Xenium In Situ data utility by quality assessment and best-practice analysis workflows. <strong>Nature Methods</strong> 2025. https://doi.org/10.1038/s41592-025-02617-2</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025-2026 JM Arbones-Mainar</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>